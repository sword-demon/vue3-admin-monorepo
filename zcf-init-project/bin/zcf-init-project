#!/usr/bin/env node

/**
 * ZCFé¡¹ç›®åˆå§‹åŒ–å·¥å…·å‘½ä»¤è¡Œå…¥å£
 */

import { Command } from 'commander';
import chalk from 'chalk';
import { ZcfInitProject } from '../src/index.js';

const program = new Command();

program
  .name('zcf-init-project')
  .description('æ™ºèƒ½é¡¹ç›®AIä¸Šä¸‹æ–‡åˆå§‹åŒ–ç³»ç»Ÿ')
  .version('1.0.0')
  .argument('[project-path]', 'é¡¹ç›®è·¯å¾„ï¼ˆé»˜è®¤ä¸ºå½“å‰ç›®å½•ï¼‰', '.')
  .option('-o, --output <path>', 'è¾“å‡ºç›®å½•ï¼ˆé»˜è®¤ä¸ºé¡¹ç›®æ ¹ç›®å½•ï¼‰')
  .option('-c, --config <path>', 'é…ç½®æ–‡ä»¶è·¯å¾„')
  .option('-f, --force', 'å¼ºåˆ¶è¦†ç›–ç°æœ‰æ–‡æ¡£')
  .option('-v, --verbose', 'è¯¦ç»†è¾“å‡º')
  .option('--phases <phases>', 'æŒ‡å®šæ‰«æé˜¶æ®µ (quick,module,deep)', 'quick,module,deep')
  .option('--max-files <number>', 'æœ€å¤§æ–‡ä»¶æ•°é™åˆ¶', '100000')
  .option('--max-depth <number>', 'æœ€å¤§æ‰«ææ·±åº¦', '10')
  .option('--timeout <number>', 'è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰', '300000')
  .option('--dry-run', 'ä»…æ˜¾ç¤ºå°†è¦æ‰§è¡Œçš„æ“ä½œï¼Œä¸å®é™…æ‰§è¡Œ')
  .option('--no-mermaid', 'ä¸ç”ŸæˆMermaidå›¾è¡¨')
  .option('--no-breadcrumbs', 'ä¸ç”Ÿæˆå¯¼èˆªé¢åŒ…å±‘')
  .option('--no-recommendations', 'ä¸ç”Ÿæˆæ¨èå»ºè®®')
  .action(async (projectPath, options) => {
    try {
      console.log(chalk.blue.bold('ğŸš€ ZCFé¡¹ç›®åˆå§‹åŒ–å·¥å…·'));
      console.log(chalk.gray(`æ­£åœ¨åˆå§‹åŒ–é¡¹ç›®: ${projectPath}`));

      if (options.verbose) {
        console.log(chalk.gray('é…ç½®é€‰é¡¹:'), JSON.stringify(options, null, 2));
      }

      const initProject = new ZcfInitProject();

      // è§£ææ‰«æé˜¶æ®µ
      const phases = options.phases.split(',').map((phase: string) => phase.trim());

      const scanOptions = {
        path: projectPath,
        outputPath: options.output,
        configFile: options.config,
        force: options.force,
        verbose: options.verbose,
        phases,
        maxFiles: parseInt(options.maxFiles),
        maxDepth: parseInt(options.maxDepth),
        timeout: parseInt(options.timeout),
        dryRun: options.dryRun,
        documentationConfig: {
          includeMermaid: options.mermaid !== false,
          includeBreadcrumbs: options.breadcrumbs !== false,
          includeRecommendations: options.recommendations !== false
        }
      };

      if (options.dryRun) {
        console.log(chalk.yellow('ğŸ” å¹²è¿è¡Œæ¨¡å¼ - ä¸ä¼šå®é™…æ‰§è¡Œæ“ä½œ'));
      }

      const result = await initProject.initialize(scanOptions);

      console.log(chalk.green.bold('âœ… åˆå§‹åŒ–å®Œæˆï¼'));
      console.log(chalk.gray(`æ‰«æç»Ÿè®¡: ${JSON.stringify(result.statistics, null, 2)}`));

      if (result.recommendations.length > 0) {
        console.log(chalk.yellow('ğŸ’¡ å»ºè®®:'));
        result.recommendations.forEach((rec, index) => {
          console.log(chalk.yellow(`${index + 1}. ${rec.title}`));
          if (options.verbose) {
            console.log(chalk.gray(`   ${rec.description}`));
          }
        });
      }

    } catch (error) {
      console.error(chalk.red.bold('âŒ åˆå§‹åŒ–å¤±è´¥:'));
      console.error(chalk.red((error as Error).message));

      if (options.verbose) {
        console.error(chalk.gray((error as Error).stack));
      }

      process.exit(1);
    }
  });

// æ·»åŠ å­å‘½ä»¤
program
  .command('config')
  .description('é…ç½®ç®¡ç†')
  .option('--init', 'åˆ›å»ºé»˜è®¤é…ç½®æ–‡ä»¶')
  .option('--validate <path>', 'éªŒè¯é…ç½®æ–‡ä»¶')
  .option('--show', 'æ˜¾ç¤ºå½“å‰é…ç½®')
  .action(async (options) => {
    try {
      const { ScanConfigManager } = await import('../src/config/scan-config.js');

      if (options.init) {
        const config = ScanConfigManager.createDefault();
        await ScanConfigManager.saveToFile(config, '.zcf-scan.json');
        console.log(chalk.green('âœ… é»˜è®¤é…ç½®æ–‡ä»¶å·²åˆ›å»º: .zcf-scan.json'));
      }

      if (options.validate) {
        const config = await ScanConfigManager.loadFromFile(options.validate);
        const validation = ScanConfigManager.validateConfig(config);

        if (validation.valid) {
          console.log(chalk.green('âœ… é…ç½®æ–‡ä»¶æœ‰æ•ˆ'));
        } else {
          console.log(chalk.red('âŒ é…ç½®æ–‡ä»¶æ— æ•ˆ:'));
          validation.errors.forEach(error => {
            console.log(chalk.red(`  - ${error}`));
          });
          process.exit(1);
        }
      }

      if (options.show) {
        try {
          const config = await ScanConfigManager.loadFromProjectRoot('.');
          const summary = ScanConfigManager.getConfigSummary(config);
          console.log(chalk.blue('ğŸ“‹ å½“å‰é…ç½®:'));
          console.log(JSON.stringify(summary, null, 2));
        } catch {
          console.log(chalk.yellow('âš ï¸  æœªæ‰¾åˆ°é…ç½®æ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤é…ç½®'));
        }
      }

    } catch (error) {
      console.error(chalk.red('âŒ é…ç½®æ“ä½œå¤±è´¥:'));
      console.error(chalk.red((error as Error).message));
      process.exit(1);
    }
  });

program
  .command('scan')
  .description('ä»…æ‰§è¡Œæ‰«æï¼Œä¸ç”Ÿæˆæ–‡æ¡£')
  .argument('[project-path]', 'é¡¹ç›®è·¯å¾„ï¼ˆé»˜è®¤ä¸ºå½“å‰ç›®å½•ï¼‰', '.')
  .option('-p, --phases <phases>', 'æŒ‡å®šæ‰«æé˜¶æ®µ (quick,module,deep)', 'quick,module,deep')
  .option('-v, --verbose', 'è¯¦ç»†è¾“å‡º')
  .option('--json', 'ä»¥JSONæ ¼å¼è¾“å‡ºç»“æœ')
  .action(async (projectPath, options) => {
    try {
      console.log(chalk.blue('ğŸ” å¼€å§‹æ‰«æé¡¹ç›®...'));

      const { ZcfInitProject } = await import('../src/index.js');
      const initProject = new ZcfInitProject();

      const phases = options.phases.split(',').map((phase: string) => phase.trim());
      const result = await initProject.scanOnly(projectPath, { phases, verbose: options.verbose });

      if (options.json) {
        console.log(JSON.stringify(result, null, 2));
      } else {
        console.log(chalk.green('âœ… æ‰«æå®Œæˆï¼'));
        console.log(chalk.blue(`ğŸ“ æ¨¡å—æ•°é‡: ${result.modules.length}`));
        console.log(chalk.blue(`ğŸ“„ æ€»æ–‡ä»¶æ•°: ${result.statistics.totalFiles}`));
        console.log(chalk.blue(`ğŸ“Š æ‰«æè¦†ç›–ç‡: ${result.statistics.coverage.toFixed(2)}%`));
        console.log(chalk.blue(`â±ï¸  æ‰«æè€—æ—¶: ${result.statistics.scanDuration}ms`));

        if (result.modules.length > 0) {
          console.log(chalk.yellow('\nğŸ“¦ å‘ç°çš„æ¨¡å—:'));
          result.modules.forEach(module => {
            console.log(chalk.yellow(`  - ${module.name} (${module.type})`));
          });
        }
      }

    } catch (error) {
      console.error(chalk.red('âŒ æ‰«æå¤±è´¥:'));
      console.error(chalk.red((error as Error).message));
      process.exit(1);
    }
  });

program
  .command('docs')
  .description('ä»…ç”Ÿæˆæ–‡æ¡£ï¼ŒåŸºäºç°æœ‰çš„æ‰«æç»“æœ')
  .argument('[project-path]', 'é¡¹ç›®è·¯å¾„ï¼ˆé»˜è®¤ä¸ºå½“å‰ç›®å½•ï¼‰', '.')
  .option('-o, --output <path>', 'è¾“å‡ºç›®å½•ï¼ˆé»˜è®¤ä¸ºé¡¹ç›®æ ¹ç›®å½•ï¼‰')
  .option('--no-mermaid', 'ä¸ç”ŸæˆMermaidå›¾è¡¨')
  .option('--no-breadcrumbs', 'ä¸ç”Ÿæˆå¯¼èˆªé¢åŒ…å±‘')
  .action(async (projectPath, options) => {
    try {
      console.log(chalk.blue('ğŸ“ å¼€å§‹ç”Ÿæˆæ–‡æ¡£...'));

      const { ZcfInitProject } = await import('../src/index.js');
      const initProject = new ZcfInitProject();

      const result = await initProject.generateDocsOnly(projectPath, {
        outputPath: options.output,
        includeMermaid: options.mermaid !== false,
        includeBreadcrumbs: options.breadcrumbs !== false
      });

      console.log(chalk.green('âœ… æ–‡æ¡£ç”Ÿæˆå®Œæˆï¼'));
      console.log(chalk.blue(`ğŸ“„ ç”Ÿæˆæ–‡æ¡£æ•°: ${result.documentsGenerated}`));
      console.log(chalk.blue(`ğŸ“ æ€»å¤§å°: ${result.totalSize} bytes`));
      console.log(chalk.blue(`â±ï¸  ç”Ÿæˆè€—æ—¶: ${result.generationTime}ms`));

    } catch (error) {
      console.error(chalk.red('âŒ æ–‡æ¡£ç”Ÿæˆå¤±è´¥:'));
      console.error(chalk.red((error as Error).message));
      process.exit(1);
    }
  });

// é”™è¯¯å¤„ç†
program.on('command:*', () => {
  console.error(chalk.red('âŒ æœªçŸ¥å‘½ä»¤ï¼Œä½¿ç”¨ --help æŸ¥çœ‹å¯ç”¨å‘½ä»¤'));
  process.exit(1);
});

// è§£æå‘½ä»¤è¡Œå‚æ•°
program.parse();